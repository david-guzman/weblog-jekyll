---
layout: post
title: "Server-sent events with JAX-RS (part 2)"
date: 2017-02-16
tags:
- Server-sent events
- SSE
- JAX-RS
- Jersey
---

Following [Part 1][post-part1], that presents a brief introduction to
Server-sent events (SSE) technology, this post will cover the implementation
of a sample SSE application based on JAX-RS.

## Source code

The complete source code of the example used in this post is available on the
weblogâ€™s [Github repo][guzman-github], in the `jaxrs-sse/jaxrs-sse-ws` folder.

Java 8 and Apache Maven 3 are required to run the code.

## Demo application

The SSE demo application consists of a JAX-RS web resource and an Angular client
which will be covered in the next post.

Each event message is built from information provided by an instance of
`ClinicEvent`.

```java
public class ClinicEvent {
  private final ClinicTeam role;
  private final String data;

  ClinicEvent(ClinicTeam role, String data) {
    this.role = role;
    this.data = data;
  }

  public ClinicTeam getRole() {
    return role;
  }

  public String getData() {
    return data;
  }
}

public enum ClinicTeam {    
  NURSE,
  REGISTRAR1,
  REGISTRAR2,
  CONSULTANT,
  RADIOLOGIST,
  PHLEBOTOMIST;
}    
```

### JAX-RS endpoint

The JAX-RS resource needs to return a response with the MIME type
`text/event-stream`. In the example this is configured with
`@Produces(SseFeature.SERVER_SENT_EVENTS)`.

Jersey provides a representation for outbound server events, `OutboundEvent`
that contains all the fields required for building individual SSEs. The resource
method does not return each `OutboundEvent` individually; instead, they return
an instance of `EventOutput`, which is a representation of the outbound SSE
channel. This allows to keep the connection open to add new events, as
specified in the javadoc.

> Outbound Server-Sent Events channel. When returned from resource method, underlying connection is kept open and application is able to send events. One instance of this class corresponds with exactly one HTTP connection.

In the following example, the JAX-RS resource method produces a stream of events
with a 1 second pause before each new event, iterating through `List<ClinicEvent> eventsList`.

```java
@GET
@Produces(SseFeature.SERVER_SENT_EVENTS)
public EventOutput getServerSentEvents() {
  final EventOutput eventOutput = new EventOutput();

  Runnable eventsTask = () -> {
    try {
      for (ClinicEvent clinicEvent : eventsList) {
        final OutboundEvent.Builder eventBuilder
                = new OutboundEvent.Builder();
        eventBuilder.name(clinicEvent.getRole().name());
        eventBuilder.mediaType(MediaType.TEXT_PLAIN_TYPE);
        eventBuilder.data(String.class, clinicEvent.getData());
        final OutboundEvent event = eventBuilder.build();
        eventOutput.write(event);
        TimeUnit.SECONDS.sleep(1);
      }

    } catch (IOException | InterruptedException e) {
      throw new RuntimeException(
              "Error when writing the event.", e);
    } finally {
      try {
        eventOutput.close();
      } catch (IOException ioClose) {
        throw new RuntimeException(
                "Error when closing the event output.", ioClose);
      }
    }
  };

  ExecutorService taskExecutor = Executors.newSingleThreadExecutor();

  taskExecutor.execute(eventsTask);
  taskExecutor.shutdown();

  return eventOutput;
}
```

## Testing

Jersey can also be used on the client side, in this case to run a simple test to
consume the messages produced by `SseAhoy`.
```java
Client client = ClientBuilder
            .newBuilder()
            .register(SseFeature.class)
            .build();
```
As with the JAX-RS resource method, the request does not return each event
individually. In this case, an instance of `EventInput` is returned, which is
read until the connection has been closed by the server.
```java
EventInput eventInput = target
           .request()
           .get(EventInput.class);
while (!eventInput.isClosed()) {
  final InboundEvent inboundEvent = eventInput.read();
  if (inboundEvent == null) {
    break;
  }
  assertTrue(SseAhoy.ClinicTeam.contains(inboundEvent.getName()));
  assertTrue(Pattern.matches(msgPattern, inboundEvent.readData(String.class)));
  System.out.println(inboundEvent.getName() + ": "
    + inboundEvent.readData(String.class));
}
```
Running `mvn verify` generates the following output as it goes through the
events.
```
Running guzman.weblog.jarxrs.sse.web.SeeAhoyIT
testGetServerSentEvents()
NURSE: Patient 97649142
REGISTRAR1: Patient 97649142
NURSE: Patient 04703214
REGISTRAR2: Patient 04703214
PHLEBOTOMIST: Patient 97649142
NURSE: Patient 98659342
CONSULTANT: Patient 98659342
NURSE: Patient 97649142
RADIOLOGIST: Patient 04703214
PHLEBOTOMIST: Patient 04703214
PHLEBOTOMIST: Patient 98659342
```

Next post will describe a simple Angular client to consume and display the
events generated by `SseAhoy`.

## Further reading
- [Java API for RESTful Services (JAX-RS)][jaxrs-api]
- [Jersey 2x user guide][jersey-docs]

[post-part1]: {{ site.baseurl }}{% post_url 2017-02-15-jaxrs-sse-1 %}
[guzman-github]: https://github.com/david-guzman/weblog-examples
[jaxrs-api]: https://jax-rs-spec.java.net/
[jersey-docs]: https://jersey.java.net/documentation/latest/index.html
